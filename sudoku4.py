board = ["4........",
		 "..3......",
		 "9...1.8..",
		 ".........",
		 ".........",
		 "..7......",
		 ".........",
		 ".........",
		 ".........",
]
#board를 리스트에 넣기

#solve함수로 문제 풀기
	
	#print(getPossibilities(2,2))
	
#solve 함수 만들기

	##칸마다 가능한 숫자 계산
	###세로
	
		###가로
		
			###9x9 칸마다 가능한 경우의 수 계산
			
			###하나만 남으면 정답이다
			
			
				
#getPossibilities 함수 만들기 (고정변수 : i,j)

	
	#board 가 .이 아닌 숫자로 채워져있을 때
	
	#칸마다 가능한 총 경우의 수 (집합을 사용 : 집합은 반복해서 빼거나 없는걸 빼도 오류가 안난다)
	
	#가로 겹치는 숫자를 제외시킨다 ex)board[1]=..1..5... -> 1,5 제외(.은 없기때문에 그냥 진행해버림)
	
	#세로 겹치는 숫자를 제외시킨다 ex)board[0~8][1]=..2..9... -> 2,9 제외(.은 없기때문에 그냥 진행해버
	
		
	
	#세로 3등분
	
	
	#가로 3등분
	
	
	#subboard 안에 겹치는 숫자를 제외시킨다 : 2차원 배열(for문 2번 사용)
	
		
#solve 함수 만들기

	##칸마다 가능한 숫자 계산
	###세로
	
		###가로
		
			###9x9 가능한 숫자 계산
			
			###+board 가 .이 아닌 숫자로 채워져있을 때
			
			###하나만 남으면 정답이다
			
#solve 함수 만들기

	#조건이 참이라면 while은 계속 돌아간다
	
		#board에 숫자가 채워지지않는 이상 다시 돌리는건 무의미하다
		
	##칸마다 가능한 숫자 계산
	###세로
	
		###가로
		
			###9x9 가능한 숫자 계산
			
			###+board 가 .이 아닌 숫자로 채워져있을 때
			
			###하나만 남으면 정답이다
			
				#정답이 나왔다는 것은 또 solve함수를 돌렸을 때, 사라질 경우의 수가 존재한다는 것이다 
				
				
		#거짓이 나왔을 경우, 연산을 끝낸다(break도 상관없을 듯)
	

#깔끔한 도출을 위해 정리


		
main()